# -*- coding: utf-8 -*-
"""QTM_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mUqpXIZaFK53nFaGXLAhTKLQ7-q6Od1T
"""

import json
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from matplotlib import pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
#mounting the drive
from google.colab import drive
drive.mount('/content/drive')

file_path = "/content/drive/MyDrive/RA RESEARCH/Andrew Trial 1.json"
file_path2 = "/content/drive/MyDrive/Qualysis Data/TrialS10002.json"
# ---- Step 1: Load the JSON file ----
with open(file_path, 'r') as f:
  data = json.load(f)
print(data.keys())
# ---- Step 2: Extract marker labels and 3D data ----
marker_section = data['Markers']
labels = [marker['Name'] for marker in marker_section]

# Print to verify
print("Available markers:", labels)

for marker in data['Markers']:
    name = marker['Name']
    x = marker.get('X', [])
    y = marker.get('Y', [])
    z = marker.get('Z', [])
    frames = len(x)
    print(f"{name}: {frames} frames | X: {len(x)}, Y: {len(y)}, Z: {len(z)}")

import pprint
print("Markers section length:", len(data['Markers']))
print("First marker example:", data['Markers'][0])

def extract_marker_xyz(marker_dict):
    """Extracts 3D [x, y, z] values from marker_dict['Parts'][0]['Values']"""
    values = marker_dict['Parts'][0]['Values']  # shape: [frames, 4]
    values = np.array(values)
    return values[:, :3]  # Drop residual column, keep [x, y, z]

marker_positions = {}

for marker in data['Markers']:
    name = marker['Name']
    try:
        marker_positions[name] = extract_marker_xyz(marker)
    except:
        print(f"Could not extract: {name}")
print(marker_positions['WRIST'].shape)  # Should be (num_frames, 3)

def compute_joint_angle(p1, p2, p3):
    v1 = p1 - p2
    v2 = p3 - p2
    v1 /= np.linalg.norm(v1, axis=1, keepdims=True)
    v2 /= np.linalg.norm(v2, axis=1, keepdims=True)
    dot_prod = np.einsum('ij,ij->i', v1, v2)
    return np.degrees(np.arccos(np.clip(dot_prod, -1.0, 1.0)))

wrist = marker_positions['WRIST']
i1 = marker_positions['I1']
i2 = marker_positions['I2']

mcp_index_angle = compute_joint_angle(wrist, i1, i2)

# Plot
import matplotlib.pyplot as plt
plt.plot(mcp_index_angle)
plt.title('Index MCP Joint Angle Over Time')
plt.xlabel('Frame')
plt.ylabel('Angle (deg)')
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

def compute_joint_angle(p1, p2, p3):
    """Computes angle at p2 formed by vectors p1-p2 and p3-p2."""
    v1 = p1 - p2
    v2 = p3 - p2
    v1 = v1 / np.linalg.norm(v1, axis=1, keepdims=True)
    v2 = v2 / np.linalg.norm(v2, axis=1, keepdims=True)
    dot_prod = np.einsum('ij,ij->i', v1, v2)
    return np.degrees(np.arccos(np.clip(dot_prod, -1.0, 1.0)))

# Define finger names and segments
fingers = {
    'Thumb':  ['T1', 'T2', 'T3'],
    'Index':  ['I1', 'I2', 'I3'],
    'Middle': ['M1', 'M2', 'M3'],
    'Ring':   ['R1', 'R2', 'R3'],
    'Pinky':  ['P1', 'P2', 'P3']
}

# Store all angles
all_angles = {}

for finger, joints in fingers.items():
    base, middle, tip = joints

    # Extract positions
    base_pos = marker_positions[base]
    mid_pos  = marker_positions[middle]
    tip_pos  = marker_positions[tip]
    wrist    = marker_positions['WRIST']

    # MCP: WRIST → BASE → MIDDLE
    mcp = compute_joint_angle(wrist, base_pos, mid_pos)

    # PIP: BASE → MIDDLE → TIP
    pip = compute_joint_angle(base_pos, mid_pos, tip_pos)

    all_angles[finger] = {
        'MCP': mcp,
        'PIP': pip
    }

# Optional: Plot example for one finger
finger_to_plot = 'Index'
plt.figure(figsize=(10, 5))
plt.plot(all_angles[finger_to_plot]['MCP'], label='MCP')
plt.plot(all_angles[finger_to_plot]['PIP'], label='PIP')
plt.title(f'{finger_to_plot} Finger Joint Angles')
plt.xlabel('Frame')
plt.ylabel('Angle (degrees)')
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import pandas as pd
import json


# --------- Extract 3D positions from data['Markers'] ---------
def extract_marker_xyz(marker_dict):
    """Extracts 3D [x, y, z] values from marker_dict['Parts'][0]['Values']"""
    values = marker_dict['Parts'][0]['Values']
    values = np.array(values)
    return values[:, :3]  # [x, y, z]

marker_positions = {}
for marker in data['Markers']:
    name = marker['Name']
    try:
        marker_positions[name] = extract_marker_xyz(marker)
    except Exception as e:
        print(f"Skipping {name}: {e}")

# --------- Define function to compute joint angle ---------
def compute_joint_angle(p1, p2, p3):
    v1 = p1 - p2
    v2 = p3 - p2
    v1 = v1 / np.linalg.norm(v1, axis=1, keepdims=True)
    v2 = v2 / np.linalg.norm(v2, axis=1, keepdims=True)
    dot_prod = np.einsum('ij,ij->i', v1, v2)
    return np.degrees(np.arccos(np.clip(dot_prod, -1.0, 1.0)))

# --------- Define fingers and compute MCP + PIP angles ---------
fingers = {
    'Thumb':  ['T1', 'T2', 'T3'],
    'Index':  ['I1', 'I2', 'I3'],
    'Middle': ['M1', 'M2', 'M3'],
    'Ring':   ['R1', 'R2', 'R3'],
    'Pinky':  ['P1', 'P2', 'P3']
}

all_angles = {}
for finger, joints in fingers.items():
    base, middle, tip = joints
    wrist = marker_positions['WRIST']
    base_pos = marker_positions[base]
    mid_pos = marker_positions[middle]
    tip_pos = marker_positions[tip]

    mcp = compute_joint_angle(wrist, base_pos, mid_pos)
    pip = compute_joint_angle(base_pos, mid_pos, tip_pos)

    all_angles[finger] = {
        'MCP': mcp,
        'PIP': pip
    }

# --------- Create a Pandas DataFrame ---------
angle_table = pd.DataFrame()
for finger, joints in all_angles.items():
    for joint_name, angle_series in joints.items():
        col_name = f"{finger}_{joint_name}"
        angle_table[col_name] = angle_series

angle_table.head()

print(angle_table.size)

file_path = "/content/drive/MyDrive/RA RESEARCH/Andrew Trial 1.json"
# ---- Step 1: Load the JSON file ----
with open(file_path, 'r') as f:
    data = json.load(f)
print(data.keys())
# ---- Step 2: Extract marker labels and 3D data ----
marker_section = data['Markers']
labels = [marker['Name'] for marker in marker_section]

# Print to verify
print("Available markers:", labels)

for marker in data['Markers']:
    name = marker['Name']
    x = marker.get('X', [])
    y = marker.get('Y', [])
    z = marker.get('Z', [])
    frames = len(x)
    print(f"{name}: {frames} frames | X: {len(x)}, Y: {len(y)}, Z: {len(z)}")

data_3d = np.array(data['Trajectories']['Labeled']['Data'])  # shape: [frames, 3, markers]

# ---- Step 3: Map markers you need ----
# Check marker names:
print("Available markers:", labels)

# Get indices for markers (adjust names as needed)
shoulder_idx = labels.index('Shoulder_L')
elbow_idx    = labels.index('Elbow_L')
wrist_idx    = labels.index('Wrist_L')

# Extract marker positions over time
shoulder = data_3d[:, :, shoulder_idx]  # [frames, x/y/z]
elbow    = data_3d[:, :, elbow_idx]
wrist    = data_3d[:, :, wrist_idx]

# ---- Step 4: Compute Elbow Joint Angles ----
def compute_joint_angle(p1, p2, p3):
    """Computes angle at p2 formed by p1-p2-p3"""
    v1 = p1 - p2
    v2 = p3 - p2
    v1 = v1 / np.linalg.norm(v1, axis=1, keepdims=True)
    v2 = v2 / np.linalg.norm(v2, axis=1, keepdims=True)
    cos_theta = np.einsum('ij,ij->i', v1, v2)
    return np.degrees(np.arccos(np.clip(cos_theta, -1.0, 1.0)))

elbow_angle_qtm = compute_joint_angle(shoulder, elbow, wrist)

# ---- Step 5: Load iPhone angles ----
iphone_df = pd.read_csv('iphone_angles.csv')  # Make sure it has 'timestamp' and 'elbow_angle'
iphone_time = iphone_df['timestamp'].values
iphone_angle = iphone_df['elbow_angle'].values

# ---- Step 6: Load QTM timestamps and sync ----
qtm_time = np.array(data['Time'])  # Usually in seconds

# Interpolate QTM angles to iPhone time
elbow_qtm_interp = np.interp(iphone_time, qtm_time, elbow_angle_qtm)

# ---- Step 7: Plot and Compare ----
plt.plot(iphone_time, iphone_angle, label='iPhone', linewidth=2)
plt.plot(iphone_time, elbow_qtm_interp, label='QTM', linewidth=2)
plt.xlabel('Time (s)')
plt.ylabel('Elbow Angle (degrees)')
plt.title('iPhone vs QTM Elbow Angle')
plt.legend()
plt.grid(True)
plt.show()

# ---- Step 8: Compute RMSE ----
rmse = np.sqrt(np.mean((elbow_qtm_interp - iphone_angle) ** 2))
print(f"RMSE between QTM and iPhone elbow angles: {rmse:.2f}°")